#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <regex.h>
#include <signal.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/time.h>

// Feel free to change the data structures generated by AI.

#define MAX_SYSCALLS 1024
#define TOP_N 5

typedef struct {
    char name[64];
    double total_time;  // 改为总时间
    int count;          // 添加调用次数
} syscall_stat;

typedef struct {
    syscall_stat stats[MAX_SYSCALLS];
    int count;
    double total_time;
} syscall_stats;

int parse_strace_line(char *line, char *syscall_name, double *time) {
    regex_t regex;
    regmatch_t matches[3]; // 0=整个匹配, 1=系统调用名, 2=时间
    
    // 编译正则表达式
    const char *pattern = "^([a-zA-Z_][a-zA-Z0-9_]*)\\(.*?\\)\\s*=.*?<([0-9.]+)>";
    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return -1; // 编译失败
    }
    
    // 执行匹配
    if (regexec(&regex, line, 3, matches, 0) == 0) {
        // 提取系统调用名
        int name_len = matches[1].rm_eo - matches[1].rm_so;
        strncpy(syscall_name, line + matches[1].rm_so, name_len);
        syscall_name[name_len] = '\0';
        
        // 提取时间
        int time_len = matches[2].rm_eo - matches[2].rm_so;
        char time_str[32];
        strncpy(time_str, line + matches[2].rm_so, time_len);
        time_str[time_len] = '\0';
        *time = atof(time_str);
        
        regfree(&regex);
        return 0; // 成功
    }
    
    regfree(&regex);
    return -1; // 匹配失败
}

void add_syscall(syscall_stats *stats, const char *name, const double time) {
    // 先查找是否已存在相同名称的系统调用
    for (int i = 0; i < stats->count; i++) {
        if (strcmp(stats->stats[i].name, name) == 0) {
            // 找到相同的系统调用，合并数据
            stats->stats[i].total_time += time;
            stats->stats[i].count++;
            stats->total_time += time;
            return;
        }
    }
    
    // 没找到相同的，创建新条目
    if (stats->count >= MAX_SYSCALLS) {
        return; // 避免数组越界
    }
    
    syscall_stat new_stat = {0};
    strcpy(new_stat.name, name);
    new_stat.total_time = time;
    new_stat.count = 1;

    stats->total_time += time;
    stats->stats[stats->count++] = new_stat;
}

void print_top_syscalls(syscall_stats *stats, int n) {
    // 直接对原始数据按总时间降序排序（冒泡排序，简单实现）
    for (int i = 0; i < stats->count - 1; i++) {
        for (int j = 0; j < stats->count - i - 1; j++) {
            if (stats->stats[j].total_time < stats->stats[j + 1].total_time) {
                syscall_stat swap = stats->stats[j];
                stats->stats[j] = stats->stats[j + 1];
                stats->stats[j + 1] = swap;
            }
        }
    }
    
    // 打印前n个
    // printf("Top %d system calls by total time:\n", n);
    printf("%-20s %10s %15s %15s\n", "Syscall", "Count", "Total Time", "Ratio(%)");
    printf("===============================================================\n");
    
    int limit = (n < stats->count) ? n : stats->count;
    for (int i = 0; i < limit; i++) {
        double ratio = stats->stats[i].total_time / stats->total_time * 100;
        printf("%-20s %10d %15.6f %15.6f\n", 
               stats->stats[i].name, stats->stats[i].count, stats->stats[i].total_time, ratio);
    }
}

int main(int argc, char *argv[]) {
    // 正确分配和初始化 exec_argv
    char **exec_argv = malloc((argc + 2) * sizeof(char*));
    exec_argv[0] = "strace";  // strace 程序名
    exec_argv[1] = "-T";      // 添加 -T 参数
    
    // 复制原始命令行参数
    for(int i = 1; i < argc; ++i){
        exec_argv[i+1] = argv[i];
    }
    exec_argv[argc+1] = NULL;  // execve 需要 NULL 结尾

    // Create a pipe
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // fork
    pid_t pid = fork();
    if (pid == -1) {
        // fork失败
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程代码
        close(pipefd[0]); // 关闭读端
        
        // 将管道写端复制到标准输出(文件描述符1)
        dup2(pipefd[1], STDOUT_FILENO);
        dup2(pipefd[1], STDERR_FILENO);
        close(pipefd[1]); // 关闭原来的写端描述符
        
        // 现在子进程的stdout会写入管道
        char *exec_envp[] = { "PATH=/usr/bin", NULL };
        execve("/usr/bin/strace", exec_argv, exec_envp);
        perror(exec_argv[0]);
        exit(EXIT_FAILURE);
    } else {
        // 父进程代码
        syscall_stats my_stats = {0}; // 初始化所有字段为0
        
        char line[1024];
        char complete_syscall[8192] = {0};
        double my_time;
        char my_name[64];

        close(pipefd[1]); // Close unused write end

        // 将文件描述符转换为FILE*流
        FILE *pipe_stream = fdopen(pipefd[0], "r");
        if (pipe_stream == NULL) {
            perror("fdopen");
            exit(EXIT_FAILURE);
        }
        
        // 记录上次打印时间（微秒精度）
        struct timeval last_print;
        gettimeofday(&last_print, NULL);
        
        // 按行读取，组合成完整的系统调用
        while (fgets(line, sizeof(line), pipe_stream) != NULL) {
            // 将当前行追加到完整系统调用中
            strncat(complete_syscall, line, sizeof(complete_syscall) - strlen(complete_syscall) - 1);
            // 检查是否以 '>' 结尾（系统调用完成）
            int len = strlen(complete_syscall);
            if (len > 0 && complete_syscall[len-1] == '\n') {
                // 检查倒数第二个字符是否是 '>'
                if (len > 1 && complete_syscall[len-2] == '>') {
                    if (parse_strace_line(complete_syscall, my_name, &my_time) == 0) {
                        add_syscall(&my_stats, my_name, my_time);
                    }
                    // 清空缓冲区，准备下一个系统调用
                    memset(complete_syscall, 0, sizeof(complete_syscall));
                }
            }
            
            // 检查是否需要打印统计信息（每100毫秒更新一次）
            struct timeval current_time;
            gettimeofday(&current_time, NULL);
            
            // 计算时间差（毫秒）
            long time_diff_ms = (current_time.tv_sec - last_print.tv_sec) * 1000 + 
                               (current_time.tv_usec - last_print.tv_usec) / 1000;
            
            if (time_diff_ms >= 100) { // 每100毫秒更新一次
                printf("\033[H\033[J");
                // printf("Real-time system call statistics (updated every 100ms):\n");
                if (my_stats.count > 0) {
                    print_top_syscalls(&my_stats, TOP_N);
                } else {
                    printf("No system calls captured yet...\n");
                }
                printf("\nPress Ctrl+C to stop...\n");
                fflush(stdout);
                last_print = current_time;
            }
        }
        
        // 最终统计
        printf("\033[H\033[J"); // 清屏
        // printf("Final system call statistics:\n");
        print_top_syscalls(&my_stats, TOP_N);
        
        fclose(pipe_stream);

        // Wait for the child to finish
        wait(NULL);

        printf("[%d] Done.\n", getpid());
        close(pipefd[0]);
    }
    
    // 释放分配的内存
    free(exec_argv);
    return 0;
}
